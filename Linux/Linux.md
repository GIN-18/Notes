# Linux

linux可以分为以下4部分:

```
1. linux内核
2. GNU工具
3. 图形化桌面环境
4. 应用软件
```

![linux系统](./images/2021-03-26_01-45.png)

## linux内核

linux系统的核心是内核。内核控制着计算机系统的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。

内核主要负责以下4中功能：

```
1. 系统内存管理
2. 软件程序管理
3. 硬件设备管理
4. 文件系统管理
```

### 系统内存管理

内核不仅管理服务器上的可用物理内存，还可以创建和管理虚拟内存。

内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为"交换空间"。内核不断地在交换空间和实际的物理内存之间反复交换虚拟内存中的内容。这使得系统以为拥有比物理内存更多的可用内存。

### 软件程序管理

linux操作系统将运行中的程序称为"进程"。内核创建了第一个进程(称为init进程)来启动系统上的所有进程。当内核启动时，内核会将init进程加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。

一些linux发行版使用一个表来管理在系统开机时要自动启动的进程。在linux系统上，这个表通常位于专门的文件/etc/inittab中。

另外一些系统则是采用/etc/init.d目录。

### 硬件设备管理

任何linux系统需要与之通信的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交换数据。在linux内核中有两种方法用于插入设备驱动代码：

```
1. 编译进内核的设备驱动代码
2. 可插入内核的设备驱动模块
```

以前，插入设备驱动代码的唯一途径是重新编译内核。每次给系统添加新设备，都要重新编译一遍内核代码。随着linux内核支持的硬件设备越来越多，这个过程变得越来越低效。因此，出现了将代码插入运行中的内核的方法。

开发人员提出了内核模块的概念。内核模块允许将驱动代码插入到运行中的内核而无需重新编译内核。同时，当设备不再使用时也可将内核模块从内核中移走。

linux系统将硬件设备当成特殊的文件，称为"设备文件"。设备文件有3种分类：

```
1. 字符型设备文件
2. 块设备文件
3. 网络设备文件
```

### 文件系统管理

linux内核支持通过不同类型的文件系统从硬盘中读写数据。除了自有的诸多文件系统外，linux还支持从其他操作系统采用的文件系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持。下面列出linux系统用来读写数据的标准文件系统。

| 文件系统 | 描述                                              |
|----------|---------------------------------------------------|
| ext      | linux扩展文件系统，最早的linux文件系统            |
| ext2     | 第二扩展文件系统，在ext的基础上提供了更多的功能   |
| ext3     | 第三扩展文件系统，支持日志功能                    |
| ext4     | 第四扩展文件系统，支持高级日志功能                |
| hpfs     | OS/2高性能文件系统                                |
| jfs      | IBM日志文件系统                                   |
| iso9660  | ISO 9660文件系统(CD-ROM)                          |
| minix    | MINIX文件系统                                     |
| msdos    | 微软的FAT16                                       |
| ncp      | Netware文件系统                                   |
| nfs      | 网络文件系统                                      |
| ntfs     | 支持Microsoft NT文件系统                          |
| proc     | 访问系统信息                                      |
| ReiserFS | 高级linux文件系统，能提供更好的性能和硬盘恢复功能 |
| smb      | 支持网络访问的Samba SMB文件系统                   |
| sysv     | 较早期的Unix文件系统                              |
| ufs      | BSD文件系统                                       |
| umsdos   | 建立在msdos上的类Unix文件系统                     |
| vfat     | Windos 95文件系统(FAT32)                          |
| XFS      | 高性能64位日志文件系统                            |

linux服务器所访问的所有硬盘都必须格式化成上表所列出的文件系统类型中的一种。

## 服务器

按外观分可以将服务器分为以下3中类型

```
1. 机架式服务器
2. 塔式服务器
3. 刀片式服务器
```

1U = 4.45cm

## linux发展历史

GNU：

GPL：

## Linux安装

### 系统分区

系统分区总共分为四步

#### 磁盘分区

磁盘分区是使用分区编辑器在磁盘上划分几个逻辑部分，碟片一旦划分成数个分区，不同类的目录和文件就可以存储仅不同的分区

**两种分区表形式**

MBR（主引导记录）分区表：最大支持2.1TB硬盘，最多支持4个分区

GPT（全局唯一标示）分区表：GPT支持9.4ZB硬盘，理论上支持的分区数没有限制，但Windows限制128个主分区

**分区类型**

```
* 主分区：最多只能分4个
* 扩展分区：只能有一个，也算作主分区的一种，也就是说主分区加扩展分区最多有4个，但是扩展分区不能存储数据和格式化，必须在划分成逻辑分区才能使用
* 逻辑分区：逻辑分区在扩展分区中划分，如果IDE硬盘，Linux最多支持59个逻辑分区，如果是SCSI硬盘Linux最多支持11个逻辑分区
```

#### 2. 格式化

格式化（高级格式化）：又称逻辑格式化，它是指根据用户选定的文件系统（如FAT16,FAT32,NTFS,EXT2,EXT3,EXT4等），在磁盘特定区域写入特定数据，在分区中划出一片用于存放文件分配表目录表等用于文件管理的磁盘空间，格式化是为了**写入文件系统**

**格式化的特点**

```
* 针对的都是分区，将分区划分成等大小的数据块（block），数据块在Linux中默认为4KB
* 数据块不一定是连续的，系统会尽量将数据块连续
* 一个数据块已经存入数据，但未使用完全也不用再写入数据
```

#### 3. 分区的设备文件名（分区的设备文件名是固定的）

| 主分区1   | /dev/sda1 |
| --------- | --------- |
| 主分区2   | /dev/sda2 |
| 主分区3   | /dev/sda3 |
| 扩展分区  | /dev/sda4 |
| 逻辑分区1 | /dev/sda5 |
| 逻辑分区2 | /dev/sda6 |
| 逻辑分区3 | /dev/sda7 |

注：

/dev/hda1（IDE硬盘接口）

/dev/sda1（SCSI硬盘接口,SATA硬盘接口）

其中a表示第一块硬盘，数字表示分区号，==逻辑分区从5号开始==

#### 4.挂载

```
1.必须分区
  * /（根分区）
  * swap分区（交换分区）
    * 如果真实内存小于4GB，swap为内存的两倍
    * 如果真实内存等于4GB，swap和真实内存一致
    * 实验环境，不大于2GB
2.推荐分区
  * /boot（启动分区，1GB）
3.常用分区
  * /home（用于文件服务器）
  * /www（用于Web服务器）
```

**挂载点**

使用已经存在的空目录作为挂载点

Windows使用的是盘符，Linux使用的挂载点

#### 安装文件

/root/install.log：存储了安装在系统中的软件包以及版本信息

/root/install.log.syslog：存储了安装过程中留下的事件记录

/root/anacinda-ks.cfg：以Kickstart配置文件的格式记录安装过程中设置的选项信息

## Linux各个目录的作用

| 目录名            | 目录作用                                                     |
| ----------------- | ------------------------------------------------------------ |
| /bin/             | 存放系统命令的目录，普通用户和超级用户都就可以执行，是/usr/bin目录的软链接。不过放在/bin/目录下的命令在到用户模式下也可以执行 |
| /sbin/            | 保存和系统环境设置有关的命令，只有超级用户可以是用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看 |
| /usr/bin/         | 存放系统命令的目录，普通用户和超级用户都可以执行，这些命令和系统启动无关，在单用户模式下不可以执行 |
| /usr/sbin/        | 存放根文件系统不必要的系统管理命令。例如，多数服务程序，只有超级用户可以使用 |
| /boot/            | 系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序（grub）文件等 |
| /dev/             | 设备文件保存位置，Linux中的作用内容都以文件的形式保存，包括硬件。/dev/目录就是用来保存所用硬件设备文件的 |
| /etc/             | 配置文件保存的位置，系统内所以采用默认安装方式（rpm安装）的服务的配置文件都保存在这个目录当中，如用户账号和密码，服务启动的脚本，常用服务的配置文件等 |
| /home/            | 普通用户的加目录，建立每个用户时，每个用户要有一个默认的登录位置，这个位置就是用户的家目录，所以普通用户的家目录就是在/home/下创建一个和用户名同名的目录，如用户user1的家目录就是/home/user1/ |
| /lib/             | 系统调用的函数库保存位置，是/usr/lib的软链接                 |
| /lib64/           | 64位函数库保存位置，是/usr/lib64的软链接                     |
| /lost+found/      | 当系统意外崩溃或机器意外关机，产生的一些文件碎片就存放在这里，当系统启动的过程中fsck工具会检查这里，并修复已损坏系统文件，这个目录只在每个分区中出现，例如/lost+found/就是根分区的备份恢复目录，/boot/lost+found/就是/boot/分区的备份恢复目录 |
| /media/           | 挂在目录，系统建议是用来挂在媒体设备的，例如软盘和光盘       |
| /mnt/             | 挂载目录，早期Linux中只有一个挂载目录，没有细分，现在这个目录系统建议挂载额外设备，例如U盘，移动硬盘和其他操作系统的分区 |
| /misc/            | 挂载目录，系统建议用来挂载NFS服务的共享目录，只要是一个已经建立的空目录就可以用作挂载点，系统默认的三个挂载目录/media/，/mnt/和/misc/中哪一个目录挂载什么设备都可以由管理员自己决定的 |
| /opt/             | 第三方软件安装保存的位置，/opt/目录就是放置和安装其他软件的位置，手动安装的软件就可以放到这个目录中，不过现在更习惯放在/usr/local/目录下，/usr/local/目录也可以用作软件的安装目录 |
| /proc/            | 虚拟文件系统，该目录中的数据并不保存在硬盘中，而是保存在内存中，主要保存的是系统内核，进程，外部设备状态和网络状态等。例如/proc/cpuinfo/是保存cpu信息的，/proc/devices/是保存设备驱动列表的，/proc/filesystems/是保存文件系统列表的，/proc/net/是保存网络协议信息的 |
| /sys/             | 虚拟文件系统，和/proc/目录相似，都是保存在内存当中的，主要是保存与内核相关的信息 |
| /root/            | 超级用户的家目录，超级用户的家目录直接在/目录下              |
| /srv/             | 服务数据目录，一些系统服务启动之后，可以在/srv/目录下保存所需要的数据 |
| /tmp/             | 临时目录，系统存放临时文件的目录，/tmp/是所用用户都可以访问和写入的目录，建议不要在这个目录下保存重要的文件，最好每次开机都把这个目录清空 |
| /usr/             | 系统软件资源目录，usr不是user的缩写，而是“Unix Software Ressource”的缩写，所以不是存放用户数据的，而是存放软件资源目录的，系统中安装的软件大多数保存在这里 |
| /usr/lib/         | 应用程序调用的函数库的保存位置                               |
| /usr/local/       | 手工安装软件的保存位置，一般建议源码包软件安装在这个位置     |
| /usr/share/       | 应用程序的资源文件保存位置。例如，帮助文档，说明文档和字体目录 |
| /usr/src/         | 源码包保存位置。手工下载的源码包和内核源码包都可以放在这个位置。更习惯把手工下载的源码包保存在/usr/local/src/目录中，把内核源码保存到/usr/src/kernels/目录中 |
| /usr/src/kernels/ | 内核源码保存位置                                             |
| /var/             | 动态数据保存的目录，主要保存缓存，日志以及软件所产生的文件   |
| /var/www/html/    | rpm包安装Apache的网页目录                                    |
| /var/lib/         | 程序运行中需要调用或改变的数据保存位置。例如，MySQL的数据库保存在/var/lib/mysql/目录中 |
| /var/log/         | 系统日志保存位置                                             |
| /var/run/         | 一些程序和服务运行后，他们的PID（进程id）保存位置，是/run/目录的软链接 |
| /var/spool/       | 放置队列数据目录，就是排队等待其他程序使用的数据。例如，邮件队列和打印队列 |
| /var/spool/mail/  | 新收到的邮件队列保存位置，系统新收到的邮件会保存在这个目录下 |
| /var/spool/cron/  | 系统的定时任务队列保存位置，系统的计划任务会保存在这个目录下 |

---

## Linux的启动过程

Linux的启动过程可以分为5个阶段：
* 内核的引导
* 运行init
* 系统初始化
* 建立终端
* 用户登录系统

### 内核引导

当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）启动

操作系统接管硬件后，首先读入/boot目录下的内核文件


### 运行init

init进程是系统所有进程的起点，没有这个进程系统中的任何进程也不会启动

init程序首先是需要读取配置文件/etc/inittab


#### 运行级别

许多程序需要开机启动，这些程序在Windows中称为“服务”（service），在Linux中称为“守护进程”（daemon）

init进程的一大任务就是运行这些开机启动的程序

但是不同场合需要启动不同的程序，例如用作服务器时，需要启动Apache，用作桌面时就不需要

Linux允许不同场合，分配不同的开机启动程序，这就叫做“运行级别”（runlevel）。也就是说启动时，根据运行级别，确定需要启动哪些i程序


Linux系统有7个运行级别：

- 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
- 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
- 运行级别2：多用户状态(没有NFS)
- 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式
- 运行级别4：系统未使用，保留
- 运行级别5：X11控制台，登陆后进入图形GUI模式
- 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动

注：

runlevel：查看运行级别

### 系统初始化

在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本

它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务

> l5:5:wait:/etc/rc.d/rc 5

这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下

而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数

/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行

而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行

这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启

至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的"System Services"来自行设定


### 建立终端

rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了

init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：

> 1:2345:respawn:/sbin/mingetty tty1
> 2:2345:respawn:/sbin/mingetty tty2
> 3:2345:respawn:/sbin/mingetty tty3
> 4:2345:respawn:/sbin/mingetty tty4
> 5:2345:respawn:/sbin/mingetty tty5
> 6:2345:respawn:/sbin/mingetty tty6

从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式

同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份

### 用户登录系统

一般来说，用户登录方式有三种：

1. 命令行登录
2. ssh登录
3. 图形界面登录


对于运行级别为5的图形方式用户来说，他们登录的是通过一个图形化界面。登录成功后可以直接进入KDE，Gnome等窗口管理器

当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了

Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数

然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出

这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录

/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制

### 图形模式和文件模式的切换方式

Linux预设提供了六个命令窗口终端机让我们来登录。

默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们

如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面

当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了

如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口

## 文件信息描述

第一个位置：-rwxr--r--

```
[ - ]表示二进制文件
[ d ]表示目录
[ l ]表示软链接
[ b ]表示装置文件里面可供存储的接口设备
[ c ]表示装置文件里面串行端口设备，例如键盘，鼠标
```

[rwx]，[r--]，[r--]每三个为一组分别对应u（所有者），g（所属组），o（其他人）

## Linux命令

#### useradd命令

添加新用户

```
useradd 用户名
```

#### ln命令

生成链接文件

```
ln <选项> <原文件> <目标文件>
```

硬链接特征

```
1. 硬链接文件和原文件拥有相同的Inode（i节点）和Block（数据块）
2. 硬链接文件和原文件可以同步更新（修改任意一个，另一个也会被修改）
3. 硬链接标记不清楚，很难确定硬链接文件的位置，不推荐使用
4. 删除任意一个文件，另一个都能使用
5. 硬链接不同跨分区使用
6. 硬链接不能针对目录使用
```

软链接特征

```
1. 软链接和原文件拥有不同的Inode（i节点）和Block（数据块）
2. 两个文件任意修改其中一个，另一个也会被修改
3. 删除软链接，原文件不受影响；删除原文件，软链接不能使用
4. 软链接没有实际数据，只是保存了原文件的Inode（i节点），无论文件多大，软链接的大小不变
5. 软链接的权限最大777，但是由于没有实际数据，最终访问时，需要参考原文件的权限
6. 软链接可以链接目录
7. 软链接可以跨分区使用
8. 软链接特征明显，推荐使用软链接
9. 软链接一定有使用绝对路径
```

#### chmod命令

改变文件或目录的权限

```
chmod <选项> <mode=421> 文件名或目录名

选项

-c：显示修改部分的信息

-R：递归修改（处理目录以及子目录）
```

权限的数字表示

```
r = 4
w = 2
x = 1
```

文件目录权限

| 代表字符 | 权限     | 对文件的含义       | 对目录的含义               |
| -------- | -------- | ------------------ | -------------------------- |
| r        | 读权限   | 可以查看文件的内容 | 可以列出目录中的内容       |
| w        | 写权限   | 可以修改文件内容   | 可以在目录中创建，删除文件 |
| x        | 执行权限 | 可以执行文件       | 可以进入目录               |

#### tar命令

打包目录，压缩后的常见格式为.tar.gz

```
tar [选项] [压缩后的文件名] [目录]
```

常用选项

```
-c：打包
-x：解包
-v：显示详细信息
-f：指定文件名
-z：打包同时压缩
```

#### cp命令

```
-r：复制目录及目录内所有项目

-p：保留文件属性
```

ps：复制同时可以改名

#### stat命令

功能描述：显示文件或文件系统的详细信息

语法：stat 文件名

#### more命令

* 空格或f：翻页
* enter：换行
* b：向上翻页
* /字符串：搜索指定字符串
* q：退出

#### head命令

功能描述：显示文件得前几行

head [选项] 文件名

#### tail命令

功能描述：显示文件的后几行

tail [选项] 文件名

#### chown命令

修改文件或目录的所有者

```
chown <用户> 文件名或目录
```

#### chgrp命令

修改文件或目录的所属组

```
chgrp <用户组> 文件名或目录
```

#### umask命令

显示，设置文件的缺省权限

```
umask [选项]
```

#### which命令

搜索命令所在目录及别命信息

```
which 命令名称
```

#### whereis命令

查找二进制命令所在目录及帮助文档路径，whereis命令不能搜索普通文件，只能搜索系统命令

```
whereis [命令名称]
```

#### passwd命令

设置用户密码

```
passwd 用户名
```

#### who命令

查看用户登录信息

```
who
```

#### w命令

查看登录用户详细信息

```
w
```

#### gzip命令

压缩文件，压缩后文件格式：.gz

```
gzip <文件>
```

#### gunzip命令

解压缩.gz格式的压缩文件

```
gunzip <压缩文件>
```

#### zip命令

压缩文件或目录

```
zip <选项> <压缩后的文件名> <需要压缩的文件或目录>
```

常用选项

```
-r：压缩目录
```

#### unzip命令

解压.zip格式的压缩文件

```
unzip [压缩文件]
```

#### bzip2命令

压缩文件，压缩后文件格式：.bz2

```
bzip2 [选项] [文件]
```

常用选项

```
-k：产生压缩文件后保留原文件
```

### bunzip2命令

解压缩.bz2格式的文件

```
bunzip2 [选项] [压缩文件]
```

常用选项

```
-k：解压后保留原文件
```

## 网络命令

### write命令

命令名称：write

命令所在路径：/usr/bin/write

执行权限：所有用户

功能描述：给用户发信息，以ctrl+d保存结束

语法：write 用户名

---

### wall命令

命令名称：wall

命令原意：write all

命令所在路径：/usr/bin/wall

执行权限：所有用户

功能描述：发送广播信息

语法：wall [信息内容]

---

### ping命令

命令名称：ping

命令所在路径：/bin/ping

执行权限：所有用户

功能描述：测试网络连通性

语法：ping [选项] ip地址

常用选项：

* -c：指定发送次数

---

### ifconfig命令

命令名称：ifconfig

命令原意：interface configure

命令所在路径：/sbin/ifconfig

执行权限：root

功能描述：查看和设置网卡信息

语法：ifconfig 网卡名称 ip地址

---

### mail命令

命令名称：mail

命令所在路径：/bin/mail

执行权限：所有用户

功能描述：查看发送邮件

语法：mail [用户名]

---

### last命令

命令名称：last

命令所在路径：/usr/bin/last

执行权限：所有用户

功能描述：列出当前与过去登录系统的用户信息

语法：last

---

### lastlog命令

命令名称：lastlog

命令所在路径：/usr/bin/lastlog

执行权限：所有用户

功能描述：检查特定用户上次登录的时间

语法：lastlog

---

### traceroute命令

命令名称：traceroute

命令所在路径：/bin/traceroute

执行权限：所有用户

功能描述：显示数据包到主机的路径

语法：traceroute

范例：traceroute www.bilibili.com

---

### tracepath命令

？

---

### netstat命令

命令名称：netstat

命令所在路径：/bin/netstat

执行权限：所有用户

功能描述：显示网络相关信息

语法：netstat [选项]

常用选项：

* -t：TCP协议
* -u：UDP协议
* -l：监听
* -r：路由
* -n：显示ip地址和端口号

范例：

* netstat -tlun ：查看本机监听的端口
* netstat -an ：查看本机所有网络连接
* netstat -rn ：查看本机路由表



---

### setup命令

命令名称：setup

命令所在路径：/usr/bin/setup

执行权限：root

功能描述：配置网络

语法：setup

注：

redhat才有

---

## 挂载命令

### mount命令

命令名称：mount

命令所在路径：/bin/mount

执行权限：所有用户

语法：mount -t [文件系统] [设备文件名] [挂载点]

也可以：mount [设备文件名] [挂载点]

umount：取消挂载

---

## 关机重启命令

在Linux领域内大多数用在服务器上，很少遇到关机的情况。除非特殊情况下，不得已才会关机

正确的关机流程：sync > shutdown > reboot > halt

sync：将数据从内存同步到硬盘

### shutdown命令

语法：shutdown [选项] 时间

常用选项：

* -c：取消前一个关机命令
* -h：关机
* -r：重启

---

## rpm软件包管理-rpm命令管理

### 软件包分类

1. 源码包
2. 二进制包（rpm包，系统默认包）

源码包的优点：

* 开源：可以查看源代码，可以修改源代码
* 可以自由的选择所需的功能
* 软件事编译安装的，所以更适合自己的系统，更加稳定高效
* 卸载方便

rpm包的优点：

* 包管理系统简单，只通过几个命令就可以实现包的安装，升级，查询和卸载
* 安装速度比源码包快很多

---

### rpm包命名规则

httpd-2.2.15-15.el6.centos.l.i686.rpm

httpd：软件包名

2.2.15：软件版本

15：软件发布次数

el6.centos：适合的Linux平台

i686：适合的硬件平台

rpm：rpm包的扩展名

**rpm包的依赖性**

树形依赖：a -> b -> c

环形依赖：a -> b -> c -> a

模块依赖：模块依赖查询网站：www.rpmfind.net

包全名：操作的包是没有安装软件包时，使用包全名，而且要注意路径

包名：操作已经安装的软件包时，使用包名。是搜索/var/lib/rpm中的数据库

---

### rpm安装

语法：rpm -ivh 包全名

常用选项：

* -i（install）：安装
* -v（verbose）：显示详细信息
* -h（hash）：显示进度
* --nodeps：不检查依赖性

---

### rpm包升级

语法：rpm -Uvh 包全名

常用选项：

* -U（upgrade）：升级

---

### rpm卸载

语法：rpm -e 包名

常用选项：

* -e（erase）：卸载
* --nodeps：不检查依赖性

---

### rpm查询

功能描述：查询包是否安装

语法：rpm -q 包名

常用选项：

* -q（query）：查询

功能描述：查询所有已经安装的包

语法：rpm -qa

常用选项：

* -a（all）：全部

功能描述：查询软件包详细信息

语法：rpm -qi 包名

常用选项：

* -i（information）：查询软件信息
* -p（package）：查询未安装包信息

功能描述：查询包中文件的安装位置

语法：rpm -ql 包名

常用选项：

* -l（list）：列表
* -p（package）：查询未安装包信息

功能描述：查询系统文件属于哪个rpm包

语法：rpm -qf 系统文件名

常用选项：

* -f（file）：查询系统文件属于哪个软件包

功能描述：查询软件包的依赖性

语法：rpm -qR 包名

常用选项：

* -R（requires）：查询软件包的依赖性
* -p（package）：查询未安装包信息

---

### rpm包校验

功能描述：查看rpm包中的文件是否被修改

语法：rpm -V 已安装包名

常用选项：

* -V（verify）：校验指定rpm包中的文件

验证内容中的8个信息：

* S：文件大小是否被修改
* M：文件类型或文件权限（rwx）是否被修改
* 5：文件MD5校验和是否被修改（可以看成文件内容是否被修改）
* D：设备是否被修改
* L：文件路径是否被修改
* U：文件所有者是否被修改
* G：文件所属组是否被修改
* T：文件修改时间是否被修改

---

### rpm包文件提取

rpm2cpio：将rpm包转换成cpio格式的命令

语法：rpm2cpio 包全名 | cpio -idv . 文件绝对路径

---

## rpm软件包管理-yum在线管理

### ip地址配置

使用setup工具

启动网卡：

vim /etc/sysconfig/network-scripts/ifcfg-???

把ONBOOT="no"改成ONBOOT="yes"

重启网络服务：

service network restart

---

### 网络yum源

yum源存放在/etc/yum.repos.d/目录下

vim /etc/yum.repos.d/CentOS-Base.repo

CentOS-Base.repo文件信息：

* [base]：容器名称，一定要放在[]中
* name：容器说明，可以自己顺便写
* mirrorlist：镜像站点，这个可以注释掉
* baseurl：yum服务器地址，默认的是CentOS官方的yum源服务器，也可以改成自己喜欢的服务器地址
* enabled：此容器是否生效，如果不写或写成enable=1都是生效，写成enable=0就是不生效
* gpgcheck：如果是1是指rpm的数字证书生效，如果是0则不生效
* gpgkey：数字证书的公钥文件保存位置，不用修改

---

### yum查询命令

功能描述：查询所有可用软件包列表

语法：yum list

功能描述：查询服务器上所有和关键字相关的包

语法：yum search 关键字（包名）

---

### yum安装命令

语法：yum [选项] install 包名

常用选项：

* -y：自动回答yes

---

### yum升级命令

语法：yum [选项] update 包名

常用选项：

* -y：自动回答yes

---

### yum卸载命令

语法：yum [选项] remove 包名

常用选项：

* -y：自动回答yes

---

### yum软件组管理命令

功能描述：列出所有可用的软件组列表

语法：yum grouplist

功能描述：安装指定软件组，组名可以用grouplist查询

语法：yum groupinstall 软件组名

功能描述：卸载指定软件组

语法：yum groupremove 软件组名

---

### rpm包安装位置

rpm包默认安装路径

| rpm包默认安装路径 |                          |
| ----------------- | ------------------------ |
| /etc/             | 配置文件安装目录         |
| /usr/bin/         | 可执行命令安装路径       |
| /usr/lib/         | 程序所使用函数库保存位置 |
| /usr/share/doc/   | 基本软件使用手册保存位置 |
| /usr/share/man/   | 帮助文档保存位置         |

**源码包安装位置**：

安装在指定位置，一般都是/usr/local/软件名/

**安装位置不同带来的影响**：

rpm包安装的服务可以使用系统服务管理命令（service）管理，例如rpm包安装的apache的启动方式是：

/etc/rc.d/init.dhttpd start

service httpd start

而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中，所以只能使用绝对路径进行服务的管理，例如：

/usr/local/apache2/bin/apachectl start

---

### 源码包安装准备

安装准备：

* 安装c语言编译器
* 下载源码包 

安装注意事项：

* 源代码保存位置：/usr/local/src/
* 软件安装位置：/usr/local/
* 如何确定安装过程报错：安装过程停止；出现error，warning或no的提示

源码包安装步骤：

* 下载源码包
* 解压缩下载的源码包
* 进入解压缩目录
* 查看INSTALL安装向导
* ./configure：软件配置与检查
* make：编译（失败的话可以执行：make clean）
* make install：编译安装

源码包的卸载：

不需要卸载命令，直接删除安装目录即可，不会遗留任何垃圾文件

---

### 脚本安装

脚本安装包并不是独立的软件包类型，常见安装的源码包

脚本安装是人把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装

类似Windows下软件的安装方式

---

## 用户和用户管理

### 用户的配置文件

Linux中主要是通过用户配置文件来查看和修改用户信息

**/etc/passwd/文件**

man 5 passwd：查看文件信息

第一字段：用户名称

第二字段：密码标志

第三字段：UID（用户ID）：

* 0：超级用户
* 1-499：系统用户（伪用户）
* 500-65535：普通用户

第四字段：GID（用户初始组ID）

注：

* 初始组：用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般初始组的组名和用户名相同
* 附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个

第五字段：用户说明

第六字段：家目录

* 普通用户：/home/用户名
* 超级用户：/root/

第七字段：登录之后的shell

注：shell就是Linux的命令解释器

---

**/etc/shadow/文件**

第一字段：用户名

第二字段：加密密码

* 加密算法升级为SHA512散列加密算法
* 如果密码位是“!!”或“*”代表没有密码，不能登录

第三字段：密码最后一次修改时间

* 使用1970年1月1日作为标准时间，每过一天时间戳加1

第四字段：两次密码的修改间隔（和第三字段相比）

第五字段：密码有效期

第六字段：密码修改到期前的警告天数（和第五字段相比）

第七字段：密码到期后的宽限天数（和第五字段相比）

* 0：表示密码过期后立即失效
* -1：表示密码永远不会失效

第八字段：账号失效时间

* 要用时间戳表示

第九字段：保留

**时间戳换算**

把时间戳换算为日期的命令：date -d"1970-01-01 16066 days"

把日期换算为时间戳的命令：echo $(($(date --date="2014/01/06"+%s)/86400+1))

---

**组信息文件/etc/group/**

第一字段：组名

第二字段：组密码标志

第三字段：GID

第四字段：组中附加用户

---

**组密码文件/etc/gshadow/**

第一字段：组名

第二字段：组密码

第三字段：组管理员用户

第四字段：组中附加用户

---

### 用户的家目录

普通用户：/home/用户名/，所有者和所属组都是此用户，权限是700

超级用户：/root/，所有者和所属组都是root用户，权限550

---

### 用户邮箱

/var/spool/mail/用户名/

---

### 用户模板目录

/etc/skel/

---

### 用户的管理命令

**用户添加命令**：useradd

语法：useradd [选项] 用户名

常用选项：

* -u（UID）：手工指定用户的UID号
* -d（家目录）：手工指定用户的家目录
* -c（用户说明）：手工指定用户说明
* -g（组名）：手工指定用户的初始组
* -G（组名）：指定用户的附加组
* -s（shell）：手工指定用户的登录shell，默认/bin/bash

**修改用户密码命令**：passwd

语法：passwd [选项] 用户名

常用选项：

* -S：查询用户密码的密码状态，仅root用户可以使用
* -l：暂时锁定用户，仅root用户可以使用
* -u：解锁用户，仅root用户可以使用
* --stdin：可以通过管道符输出的数据作为用户的密码

**修改用户信息命令**：usermod

语法：usermod [选项] 用户名

常用选项：

* -u（UID）：修改用户的UID号
* -c（用户说明）：修改用户的说明信息
* -G（组名）：修改用户的附加组
* -L （Lock）：临时锁定用户
* -U（Unlock）：解锁用户锁定

**修改用户密码状态命令**：chage

语法：chage [选项] 用户名

常用选项：

* -l：列出用户的详细密码状态
* -d（日期）：修改密码最后一次更改日期（shadow的第三字段）
* -m（天数）：两次密码修改间隔（shadow第四字段）
* -M（天数）：密码有效期（shadow第五字段）
* -W（天数）：密码过期前警告天数（shadow第六字段）
* -I（天数）：密码过期后宽限天数（shadow第七字段）
* -E（日期）：账号失效时间（shadow第八字段）

**删除用户命令**：userdel

语法：userdel [选项] 用户名

常用选项：

* -r：删除用户的同时删除用户的家目录

**切换用户命令**：su

语法：su [选项] 用户名

常用选项：

* -：选项只使用“-”代表连带用户的环境变量一起切换
* -c：仅执行一次命令，而不切换用户身份

---

### 用户默认值文件

**/etc/default/useradd**

用户默认组：GROUP=100

用户家目录：HOME=/home

密码过期宽限天数（shadow文件第七字段）：INACTIVE=-1

密码失效时间：EXPIRE=

默认shell：SHELL=/bin/bash

模板目录：SKEL=/etc/skel

是否建立邮箱：CREATE_MAIL_SPOOL=yes

**/etc/login/defs文件**

密码有效时间（5）：PASS_MAX_DAYS 99999

密码修改间隔（4）：PASS_MIN_DAYS 0

密码最小5数（PAM）：PASS_MIN_LEN 5

密码到期警告（6）：PASS_WARN_AGE 7

最小和最大UID范围：UID_MAX 500；GID 60000；

加密模式：ENCRYPT_METHOD SHA512

---

### 用户组管理命令

**添加用户组命令**：groupadd

语法：groupadd [选项] 组名

常用选项：

* -g（GID）：指定组ID

**修改用户组命令**：groupmod

语法：groupmod [选项] 组名

常用选项：

* -g（GID）：修改组ID
* -n：修改组名

**删除用户组命令**：groupdel

语法：groupdel 组名

**把用户添加入组或从组中删除**：gpasswd

语法：gpasswd [选项] 组名

常用选项：

* -a（用户名）：把用户添加入组
* -d（用户名）：把用户从组中删除

---

## 权限管理

### ACL权限

ACL权限是为了防止权限不够用的情况，一般的权限有所有者，所属组和其他人三种，当这三种不能满足我们的需求时就可以使用ACL权限，需要分区支持才能分配ACL权限，==ACL权限默认开启==

**查看分区ACL权限是否开启**：dumpe2fs -h /dev/sda3

dumpe2fs命令是查询指定分区详细文件系统信息的命令

常用选项：

* -h：仅显示超级块中信息，而不是显示磁盘块组的详细信息

注：centos 7使用的文件系统是xfs，而不是ext2/ext3/ext4，所以不能使用dumpe2fs命令查询，需要使用xfs_info查看

**临时开启分区ACL权限**：mount -o remount,acl /

注：上面的命令重新挂载了根分区，并挂载加入acl权限

**永久开启分区ACL权限**：vim /etc/fstab

修改：UUID=****；在此代码中添加acl


重新挂载文件系统或重启系统，使修改生效：mount -o remount /

---

### 查看ACL命令

**查看ACL权限**

语法：getfacl 文件名

**设定ACL权限**

语法：setfacl [选项] [u:用户名:分配的权限 or g:组名:分配的权限] 文件名

常用选项：

* -m：设定ACL权限
* -x：删除指定的ACL权限
* -b：删除所有的ACL权限
* -d：设定默认ACL权限
* -k：删除默认ACL权限
* -R：递归设定ACL权限

---

### 最大有效权限mask

mask是用来指定最大有效权限的，如果我给用户赋于了ACL权限，是需要和mask的权限“相与”才能的到用户真正的权限

**调整mask最大有效权限**

语法：setfacl [选项] [m:分配的权限] 文件名

### 删除ACL权限

删除指定用户或指定组的ACL权限

语法：语法：setfacl -x [u:用户名 or g:组名] 文件名

---

### 默认ACL权限

默认ACL权限的作用是如果给父目录设定了默认ACL权限，那么父目录中的所有新建的子文件都会继承父目录的ACL权限

语法：setfacl -m d:u:用户名:分配的权限 -R 目录

### 递归ACL权限

递归是父目录在射设定ACL权限时，所有子文件和子目录也拥有相同的ACL权限

语法：setfacl -m u:用户名:分配的权限 -R 目录

---

### 文件特殊权限

**SetUID的功能**

* 只有可以执行的二进制程序才能设定SUID权限

* 命令执行者要对该程序拥有x（执行权限）

* 命令执行者在执行该程序时获得该程序文件属主的身份（在执行程序的过程中灵魂附体为文件的属主）

* SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效

* passwd命令拥有SetUID权限，所以普通用户可以修改自己的密码


**设定SetUID的方法**

4代表SUID

语法：

* chmod 4755文件名
* chmod u+s 文件名

**取消SetUID权限**

语法：

* chmod 755 文件名
* chmod u-s 文件名

**危险的SetUID**

* 关键目录应严格控制写权限，例如“/”，“/usr”等
* 用户密码设置要严格遵循密码三原则
* 对系统默认应该具有SetUID权限的文件作一列表，定时检查有没有之外的文件被设置了SetUID权限 

---

**SetGID针对目录的作用**

* 普通用户必须对此目录拥有r（读权限）和x（执行权限），才能进入目录

* 普通用户在此目录中的有效组会变成此目录的所属组

* 若普通用户对此目录拥有w（写权限）时，新建的文件的默认所属组是这个目录的所属组

* 只有可执行的二进制程序才能设置SGID权限

* 命令执行者要对该程序拥有x（执行权限）

* 命令执行者在执行程序时，组身份升级为该程序文件的所属组

* SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效

* locate命令拥有SGID权限


* /usr/bin/locate是可执行二进制程序，可以赋于SGID

* 执行用户对/usr/bin/locate命令拥有执行权限

* 执行/usr/bin/locate命令时，组身份会升级为slocate组，而slocate组对/var/lib/mlocate/mlocate.db数据库拥有r（读权限），所以普通用户可以使用locate命令查询mlocate.db数据库

* 命令结束时，用户的组身份变回原来的组

**设定SGID**

2代表SGID

* chmod 2755 文件名
* chmod g+s 文件名

**取消SGID**

* chmod 755 文件名
* chmod g-s 文件名

---

**Sticky BIT（SBIT）粘着位作用**

* 粘着位目前指针对目录有效

* 普通用户对该目录拥有w（写权限）和x（执行权限），即普通用户可以在此目录拥有写入权限

* 如果没有粘着位，因为普通用户拥有w（写权限），所以可以删除此目录下的所有文件，包括其他用户建立的文件，一旦赋于粘着位，除了root可以删除所有文件，普通用户就算拥有w（写权限），也只能删除自己创建的文件，而不能删除其他用户创建的文件

* 拥有粘着位的目录/tmp/


**设置SBIT粘着位**

* chmod 1755 目录名
* chmod o+t 目录名

**取消SBIT粘着位**

* chmod 755 目录名
* chmod o-t 目录名

---

### 文件系统属性chattr权限

**chattr命令**

语法：chattr [+ - =] [选项] 文件或目录名

+：增加权限

-：删除权限

=：等于某权限

常用选项：

* -i：如果对文件设置[ i ]属性，那么不允许对文件进行删除，改名，也不能添加和修改数据；如果对目录设置[ i ]属性，那么只能修改目录下文件的数据，但不允许建立和删除文件
* -a：如果对文件设置[ a ]属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置[ a ]属性，那么只允许在目录中建立和修改文件，但不允许删除

**查看文件系统属性**

lsattr命令

语法：lsattr [选项] 文件名

常用选项：

* -a：显示所有文件和目录
* -d：如目标是目录，仅列出目录本身的属性，而不是子文件的属性

---

### **系统命令sudo权限**

**sudo权限**

* root把本来只能超级用户执行的命令赋于普通用户执行
* sudo的操作对象是系统命令

**sudo的使用**

修改的是/etc/sudoers文件

root用户：visudo


上图说明：

* 第一字段：用户名
* 第二字段：被管理主机的地址=（可使用的身份）
* 第三字段：授权命令（绝对路径）


上图说明：

* 第一字段：组名
* 第二字段：被管理主机的地址=（可使用的身份）
* 第三字段：授权命令（绝对路径）

查看root用户赋于普通用户哪些命令：sudo -l

---

## 文件系统管理

### 文件系统

ext2：是ext文件系统升级版本，RedHat Linux7.2版本之前的系统默认都是ext2文件系统，1993年发布，最大支持16TB的分区和最大2TB的文件

ext3：ext3文件系统是ext2文件系统的上级版本，最大区别就是带日志功能，以在系统突然停止时提高文件系统的可靠性，支持最大16TB的分区和最大2TB的文件

ext4：是ext3文件系统的升级版本，ext4在性能，伸缩性和可靠性方面进行了大量的改进，例如向下兼容ext3，最大1EB文件系统的16TB文件，无线数量子目录等，是CentOS 6.3默认文件系统

CentOS 7使用的xfs文件系统

---

### 文件系统常用命令

**文件系统查看命令df**

语法：df [选项] [挂载点]

常用选项：

* -a：显示所有文件系统的信息，包括特殊文件系统，例如/proc，/sysfs
* -h：使用习惯单位显示容量，例如KB，MB或GB等
* -T：显示文件系统类型
* -m：以MB为单位显示容量
* -k：以KB为单位显示容量，默认就是以KB为单位显示

---

### 统计目录和文件大小

语法：du [选项] [目录或文件名]

常用选项：

-a：显示每个子文件的磁盘占用量，默认只统计子目录的磁盘占用量

-h：使用习惯单位显示磁盘占用量，例如KB，MB或GB等

-s：统计总占用量，而不列出子目录和子文件的占用量

---

### du命令和df命令的区别

df命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令画出程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）

du命令是面向文件的，只会计算文件或目录占用的空间

---

### 文件系统修复命令fsck

语法：fsck [选项] 分区设备文件名

常用选项：

* -a：不用显示用户提示，自动修复文件系统
* -y：自动修复。和-a作用一致，不过有些文件只支持-y

---

### 查询和自动挂载

查询系统中已经挂载的设备，[ -l ]会显示卷标名称

语法：mount -l

依据配置文件/etc/fstab的内容，自动挂载

语法：mount -a

---

### 挂载命令格式

语法：mount [选项] 设备名称 挂载点

常用选项：

* -t（文件系统）：加入文件系统类型来指定挂载的类型，可以ext3，ext4等文件系统
* -L（卷标名）：挂载指定卷标的分区，而不是安装设备文件名挂载
* -o（特殊选项）：可以指定挂载的额外选项

---

### 挂载光盘和u盘

只要是一个空目录就可以用作挂载点

光盘的设备文件名是固定的（/dev/sr0或/dev/cdrom）

**挂载光盘**

建立挂载点：mkdir /mnt/cdrom/

挂载光盘：mount -t iso9660 /dev/cdrom/ /mnt/cdrom/ 或 mount /dev/sr0 /mnt/cdrom

**卸载命令**

语法：unmount 设备文件名或挂载点

**挂载u盘**

u盘的设备文件名是u盘插入后系统自动分配的，因为u盘使用的是硬盘的设备文件名，而每台服务器上插入的硬盘数量和分区方式都不一样，所以u盘的设备号需要单独检测

u盘的设备文件名是系统自动分配的，只需要查出设备文件名然后挂载就可以了

> * 插入u盘
> * 查看u盘设备文件名：fdisk -l
> * 再使用挂载命令挂载：mount -t vfat 设备文件名 挂载点

注：vfat是文件格式系统

乱码情况：是因为u盘是Windows中保存的数据，而Windowsvv中的中文编码格式和Linux的不一致，只需要在挂载的时候指定正确的编码格式就可以解决乱码问题。命令如下：

mount -t vfat -o iocharset=utf8 设备文件名 挂载点

---

### fdisk分区

**fdisk命令分区过程**

* 添加一块新硬盘

* 查看新硬盘：fdisk -l

* 使用fdisk命令分区：fdisk /dev/sdb

  | fdisk交互指令说明 |                                                           |
  | ----------------- | --------------------------------------------------------- |
  | a                 | 设置可引导标记                                            |
  | b                 | 编辑bsd磁盘标签                                           |
  | c                 | 设置DOS操作系统兼容标记                                   |
  | d                 | 删除一个分区                                              |
  | l                 | 显示已知的文件系统类型，82为Linux swap分区，83为Linux分区 |
  | m                 | 显示帮助菜单                                              |
  | n                 | 新建分区                                                  |
  | o                 | 建立空白DOS分区表                                         |
  | p                 | 显示分区列表                                              |
  | q                 | 不保存退出                                                |
  | s                 | 新建空白SUN磁盘标签                                       |
  | t                 | 改变一个分区的系统ID                                      |
  | u                 | 改变显示记录单位                                          |
  | v                 | 验证分区表                                                |
  | w                 | 保存退出                                                  |
  | x                 | 附加功能（仅专家）                                        |

* 重新读取分区表信息：partprobe

* 格式化分区：mkfs -t ext4（文件系统类型） /dev/sdb

* 建立挂载点并挂载：mkdir /disk1 && mount /dev/sdb1 /disk1

---

### 分区自动挂载与fstab文件修复

分区自动挂载主要是写入/etc/fstab文件中

**/etc/fstab文件**

第一字段：分区设备文件名或UUID（硬盘通用唯一识别码）

第二字段：挂载点

第三字段：文件系统名称

第四字段：挂载参数

第五字段：指定分区是否被dumpe备份，0表示不备份，1表示每天备份，2表示不定期备份

第六字段：指定分区是否被fsck检测，0表示不检测，其他数字表示检测优先级，1的优先级比2高

---

## shell基础

### shell概述

shell是一个命令解释器，shell为用户提供一个向Linux内核发送请求以便运行程序的界面系统及程序，用户可以用shell来启动，挂起，停止甚至编写一些程序

shell还是一个功能强大的编程语言，易编写，易调试，灵活性强。shell是解释执行的脚本语言，在shell中可以直接调用Linux系统命来

**shell的分类**

Bourne Shell：从1979年起Unix就开始使用，Bourne Shell的文件名为sh

C Shell：主要在BSD版的Unix系统中使用，其语言和C语言类似而得名

shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容

Bourne家族主要有sh，ksh，Bash，psh，zsh

C家族主要有csh，tcsh

Bash：与sh兼容，现在使用的Linux就是使用Bash作为用户的基本shell

**Linux支持的shell**

可以查看/etc/shells文件

---

### shell脚本的执行方式

> * 赋于执行权限，直接运行：chmod 755 hello.sh && ./hello.sh
> * 通过Bash调用执行脚本：bash hello.sh

**echo输出命令**

语法：echo [选项] [输入内容]

常用选项：

* -e：支持反斜线控制的字符转换

---

### 历史history命令

语法：history [选项] [历史命令保存文件]

常用选项：

* -c：清空历史命令
* -w：把缓存中的历史命令写入历史命令保存文件~/.bash_history

历史命令默认保存1000条，可以在环境变量配置文件/etc/profile中进行修改

**历史命令的调用**

* 使用上，下箭头可以调用以前的历史命令
* 使用“!n”重复执行第n条历史命令
* 使用“!!”重复执行上一条命令
* 使用“!字串”重复执行最后一条以该字串开头的命令

**命令与文件补全**

在bash中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令与文件时，按“Tab”键就会自动补全

---

### 命令别名与常用快捷键

**命令别名**

设定命令别名：alias 别名='原命令'

查询命令别名：alias

**命令执行顺序**

第一顺位执行用绝对路径或相对路径执行的命令

第二顺位执行别名

第三顺位执行bash的内部命令

第四顺位执行按照$PATH环境变量定义的目录查找的顺序找到的第一个命令

**让别名永久生效**

修改/root/.bashrc文件

**删除别名**

语法：unalias 别名

**bash常用快捷键**

| 快捷键 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| ctrl+a | 把光标移动到命令行开头                                       |
| ctrl+e | 把光标移动到命令行尾部                                       |
| ctrl+c | 强制终止当前的命令                                           |
| ctrl+l | 清屏，相当于clear命令                                        |
| ctrl+u | 删除或剪切光标前的内容                                       |
| ctrl+k | 删除或剪切光标后的内容                                       |
| ctrl+y | 粘贴ctrl+u或ctrl+k剪切的内容                                 |
| ctrl+r | 在历史命令中搜索，按下ctrl+r后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索 |
| ctrl+d | 退出当前终端                                                 |

---

### 输入/输出重定向

**标准输入输出**

| 设备   | 设备文件名  | 文件描述符 | 类型         |
| ------ | ----------- | ---------- | ------------ |
| 键盘   | /dev/stdin  | 0          | 标准输入     |
| 显示器 | /dev/sdtout | 1          | 标准输出     |
| 显示器 | /dev/sdterr | 2          | 标准错误输出 |

**输出重定向**

把原本输出到显示器上的内容输出到指定的文件当中

| 类型                           | 符号                    | 作用                                                         |
| ------------------------------ | ----------------------- | ------------------------------------------------------------ |
| 标准输出重定向                 | 命令 > 文件             | 以覆盖的方式，把命令的正确输出结果输出到指定的文件或设备当中 |
|                                | 命令 >> 文件            | 以追加的方式，把命令的正确输出结果输出到指定的文件或设备当中 |
| 标准错误输出重定向             | 错误命令 2> 文件        | 以覆盖的方式，把命令的错误输出结果输出的指定的文件或设备当中 |
|                                | 错误命令 2>> 文件       | 以追加的方式，把命令的错误输出结果输出到指定的文件或设备当中 |
| 正确的输出和错误的输出同时保存 | 命令 > 文件 2>&1        | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中     |
|                                | 命令 >> 文件 2>&1       | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中     |
|                                | 命令 &> 文件            | 以覆盖的方式，把正确输出和错误输出到保存到同一个文件当中     |
|                                | 命令 &>> 文件           | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中     |
|                                | 命令 >> 文件1 2>> 文件2 | 把正确输出追加到文件1中，把错误的输出追加到文件2中           |

**输入重定向**

语法：wc [选项] 文件名

常用选项：

* -c：统计字节数
* -w：统计单词数
* -l：统计行数

命令 < 文件

---

### 多命令顺序执行和管道符

**多命令顺序执行**

| 多命令执行符 | 格式             | 作用                                                         |
| ------------ | ---------------- | ------------------------------------------------------------ |
| ;            | 命令1 ; 命令2    | 多命令顺序执行，命令之间没有任何逻辑联系                     |
| &&           | 命令1 && 命令2   | 逻辑与：当命令1正确执行，则命令2才会执行；当命令1执行不正确，则命令2不会执行 |
| \|\|         | 命令1 \|\| 命令2 | 逻辑或：当命令1执行不正确，则命令2才会执行；当命令1正确执行，则命令2不会执行 |

**管道符**

命令格式：命令1 | 命令2

说明：命令1正确输出作为命令2的操作对象

### grep命令

命令名称：grep

命令所在路径：/bin/grep

执行权限：所有用户

功能描述：grep是==行过滤==工具，用于根据关键字进行==行过滤==

语法：

> grep [选项] '关键字' 文件名

常用选项：

>* -i：不区分大小写
>* -n：输出行号
>* -v：反向查找
>* -w：按单词搜索
>* -o：打印匹配关键字
>* -r：逐层遍历目录查找
>* -A：显示匹配行以及匹配行的后多少行
>* -B：显示匹配行以及匹配行的前多少行
>* -C：显示匹配行以及匹配行的前后多少行
>* -l：只列出匹配的文件名
>* -L：列出不匹配的文件吗
>* -e：使用正则匹配
>* -E：使用扩展正则匹配
>* ^key：以关键字（key）开头的
>* key$：以关键字（key）结尾的
>* --color=auto：搜索出的关键字用颜色显示

---

### 通配符与其他基本符号

| 通配符 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| ?      | 匹配一个任意字符                                             |
| *      | 匹配0个或任意多个任意字符，也可以说匹配任何内容              |
| []     | 匹配中括号任意一个字符，例如[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c |
| [-]    | 匹配中括号任意一个字符，-代表一个范围，例如[a-z]代表匹配一个小写字母 |
| [^]    | 逻辑非，代表匹配不是中括号内的一个字符，例如[^0-9]           |

[^0-9]: 代表匹配一个不是数字的字符

---

### bash中其他特殊符号

| 符号 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| ''   | 单引号，在单引号中的所有特殊字符号，例如“$”和“`”（反引号）都没有特殊含义 |
| ""   | 双引号，在双引号中特殊符号都没有特殊含义，但是“$”,“`”和“\”是例外，拥有“调用变量的值”，“引用命令”和“转义符”的特殊含义 |
| ``   | 反引号，反引号括起来的内容是指系统命令，在bash中会优先执行它，和$()作用一样，不过推荐使用$()，因为反引号非常容易看错 |
| $()  | 和反引号作用一样，用来引用系统命令                           |
| #    | 在shell脚本中，#开头的表示注释                               |
| $    | 用于调用变量的值，例如需要调用变量name的值，需要使用$name的方式得到变量的值 |
| \    | 转义符，跟在\之后的特殊符号将失去特殊含义，变为普通符号，例如[^\$] |

[^\$]: 输出的是“$”符号，而不是用作变量引用

---

### bash的变量

**变量的分类**

>* 用户自定义变量
>* 环境变量：环境变量主要保存的是和系统操作环境相关的数据
>* 位置参数变量：位置参数变量主要是用来向脚本传递参数或数据的，变量名不能自定义，变量作用是固定的
>* 预定义变量：是bash中已经定义好的变量，变量名不能自定义，变量的作用也是固定的

**用户自定义变量**

变量是计算机内存的单元，其中存放的信息可以改变，当shell脚本需要保存一些信息时，例如一个文件名或一个数字，就把他存放在一个变量当中，每个变量都有一个名字，所以容易引用他，使用变量可以保存有用信息，使系统获知勇士相关设置，变量也可以用于保存暂时信息

**变量设置规则**

> * 变量名称可以由字母，数字或下划线组成，但是不能以数字开头，例如“2name”就是无效变量名
> * 在bash当中，变量的默认类型都是字符串类型，如果需要进行数值运算，则必须指定变量的类型为数值型
> * 变量用等号连接，等号左右两侧不能有空格
> * 变量的值如果有空格，需要使用单引号或双引号包括
> * 在变量的值中可以使用“\”转义符
> * 如果需要增加变量的值，那么可以进行变量的叠加，不过变量需要使用双引号包括“$变量名”或使用${变量名}包括
> * 如果是把命令的结果作为变量的值赋于变量，则需要使用"$()"或反引号包括命令
> * 环境变量名建议大写，便于区分

**定义变量**

```shell
name="ginxq"
```

变量名就是name

**变量叠加**

```shell
aa=123
aa="$aa"456
aa=${aa}789
```

**变量调用**

```shell
echo $name
```

**查看变量**

例如：set

**删除变量**

例如：unset 变量名

---

**环境变量**

用户自定义变量只能在当前的shell中生效，而环境变量会在当前shell和着个shell的所有子shell当中都生效，如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有shell中生效

**设置环境变量**

申明变量：export 变量名=变量值

查询变量：env

删除变量：unset 变量名

**系统常见环境变量**

PATH：系统查找命令路径

PATH变量叠加：PATH="$PATH":/root/sh

**PS1:定义系统提示符的变量**

| \d        | 显示日期，格式为“星期 月 日”                                 |
| --------- | ------------------------------------------------------------ |
| \h        | 显示简写主机名，例如默认主机名“localhost”                    |
| \t        | 显示24小时时间制时间，格式为“HH:MM:SS”                       |
| \T        | 显示12小时时间制时间，格式为“HH:MM:SS”                       |
| \A        | 显示24小时时间制时间，格式为“HH:MM”                          |
| \u        | 显示当前用户                                                 |
| \w        | 显示当前所在目录的完整名称                                   |
| \W        | 显示当前所在目录的最后一个目录                               |
| \井号     | 执行的第几个命令                                             |
| \美元符号 | 提示符，如果是root用户显示提示符为“#”，如果是普通用户会显示提示符为“$” |

例如：PS1='[\u@\t \w]\美元符号 '可以修改PS1的格式

---

**位置参数变量**

| 位置参数变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| $n           | n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包括，例如${10} |
| $*           | 这个变量代表命令行中的所有参数，$*把所有的参数看成一个整体   |
| $@           | 这个变量也代表命令行中的所有参数，不过$@把每个参数区分对待   |
| $#           | 这个参数代表命令行中所有参数的个数                           |

---

**预定义变量**

| 预定义变量 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| $?         | 最后一次命令执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行，如果这个变量的值为非0（具体哪一个数字由命令自己决定），则证明上一个命令执行不正确 |
| $$         | 当前进程的进程号（PID）                                      |
| $!         | 后台运行的的最后一个进程的进程号（PID）                      |

**接受键盘输入**

语法：

> read [选项] [变量名]

常用选项：

>* -p（提示信息）：在等待read输入时，输出提示信息
>* -t（秒数）：read命令会一直等待用户输入，使用此选项可以指定等待时间
>* -n（字符数）：read命令只接受指定的字符数，就会执行
>* -s：隐层输入的数据，适用于机密信息的输入

---

### bash算数运算和运算符

**declare命令声明变量类型**

语法：

> declare [选项] 变量名

常用选项：

>* -：给变量设定类型属性
>* +：取消变量的类型属性
>* -i：将变量声明为整数型
>* -x：将变量声明为环境变量
>* -p：显示指定变量的变量类型

**数值运算方法**

方法1

```shell
aa=11
bb=22
declare -i cc=$aa+$bb
```

方法2：expr或let数值运算工具

```shell
aa=11
bb=22
dd=$(expr $aa + $bb)
```

注意：“+”号两侧必须有空格

方法3："$((运算式))"或''$[运算式]"

```shell
aa=11
bb=22
ee=$(($aa+$bb)) or ff=$[$aa+$bb]
```

**运算符**

| 优先级 | 运算符                | 说明                           |
| ------ | --------------------- | ------------------------------ |
| 13     | -，+                  | 单目负，单目正                 |
| 12     | !，~                  | 逻辑非，按位取反               |
| 11     | *，/，%               | 乘，除，取模                   |
| 10     | +，-                  | 加，减                         |
| 9      | <<，>>                | 按位左移，按位右移             |
| 8      | < =，> =，<，>        | 小于等于，大于等于，小于，大于 |
| 7      | ==，!=                | 等于，不等于                   |
| 6      | &                     | 按位与                         |
| 5      | ^                     | 按位异或                       |
| 4      | \|                    | 按位或                         |
| 3      | &&                    | 逻辑与                         |
| 2      | \|\|                  | 逻辑或                         |
| 1      | =，+=，-=，*=，/= etc | 赋值，运算且赋值               |

**环境变量配置文件**

>* /etc/profile
>* /etc/profile.d/*.sh
>* ~/.bash_profile
>* ~/.bashrc
>* /etc/bashrc

**环境变量配置文件的优先级**


**/etc/profile文件的作用**

定义了USER变量

定义了LOGNAME变量

定义了MAIL变量

定义了PATH变量

定义了HOSTNAME变量

定义了HISTSIZE变量

定义了umask

调用了/etc/profile.d/*.sh文件

使环境变量生效：source 配置文件 or . 配置文件

**环境变量配置文件简介**

环境变量配置文件中主要是定义对系统操作环境生效的系统默认环境变量，例如PATH,HISTSIZE,PS1,HOSTHOME等默认环境变量

**注销时生效的环境变量配置文件**：~/.bash_logout

**本地终端的欢迎信息**：/etc/issue

| 转义符 | 作用                               |
| ------ | ---------------------------------- |
| \d     | 显示当前系统日期                   |
| \s     | 显示操作系统名称                   |
| \l     | 显示登录的终端号（常用）           |
| \m     | 显示硬件体系结构，例如i386，i686等 |
| \n     | 显示主机名                         |
| \o     | 显示域名                           |
| \r     | 显示内核版本                       |
| \t     | 显示当前系统时间                   |
| \u     | 显示当前登录用户的序列号           |

**远程登陆欢迎信息**：/etc/issue.net

转义字符在/etc/issue.net文件中不能使用

是否显示此欢迎信息，有ssh配置文件/etc/ssh/ssh_config决定，加入“Banner /etc/issue.net”行才能显示（记得重启ssh服务）

**登录后欢迎信息**：/etc/motd

不管是本地登录还是远程登录，都可以显示欢迎信息

---

### 正则表达式

**正则表达式和通配符**

正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。gerp，awk，sed等命令	可以支持正则表达式

通配符用来匹配符合条件的文件名，通配符是完全匹配。ls，find，cp等命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配

**基础正则表达式**

| 元字符            | 作用                                           |
| ----------------- | ---------------------------------------------- |
| *                 | 前一个字符匹配0次或任意多次                    |
| .                 | 匹配除了换行符外任意一个字符                   |
| ^                 | 匹配行首                                       |
| $                 | 匹配行尾                                       |
| []                | 匹配中括号中指定的任意一个字符，只匹配一个字符 |
| [^]               | 匹配除了中括号的字符以外的任意一个字符         |
| \                 | 转义字符，用于取消特殊符号的含义               |
| 右斜杠{n右斜杠}   | 表示其前面的字符恰好出现n次                    |
| 右斜杠{n,右斜杠}  | 表示其前面的字符出现不小于n次                  |
| 右斜杠{n,m右斜杠} | 表示其前面的字符出现至少n次                    |

**“*”：前一个字符匹配0次或任意多次**

**例如**

**匹配所有内容，包括空白行**：grep "a*" 文件名

**匹配至少一个包含a的行**：grep "aa*" 文件名

**匹配最少包含两个连续a的行**：grep "aaa*" 文件名

---

**“.”匹配除了换行符以外任意一个字符**

**例如**

**“s..d”匹配在s和d之间一定有两个字符的单词**：grep "s..d" 文件名

**匹配在s和d之间有任意字符**：grep "s.*d" 文件名

**匹配所有内容**：grep ".*" 文件名

---

**"^"匹配行首，"$"匹配行尾**

**例如**

**匹配以大写“M”开头的行**：grep "^M" 文件名

**匹配以小写“n”结尾的行**：grep "n$" 文件名

**匹配空行**：grep -n "^$" 文件名

---

**“[]”匹配中括号中指定的任意一个字符，只匹配一个字符**

**例如**

**匹配s和o字母中，要不是a，要不是o**：grep "s[aoid]" 文件名

**匹配任意一个数字**：grep "[0-9]" 文件名

**匹配以小写字母开头的行**：grep "[^a-z]" 文件名

[^a-z]: 匹配以小写字母开头的行

---

### cut字段提取命令

功能描述：cut是==列截取==工具，用于==列的截取==

语法：

> cut [选项] 文件名

常用选项：

>* -c：以字符为单位进行分割，截取
>* -f（列号）：与-d一起使用，指定截取哪个区域（哪一列）
>* -d（分隔符）：自定义分隔符，按照指定分隔符分割列，默认为制表符\t

例如：

> 以冒号“:”为分割符，截取第一列和第六列：cut -d: -f1,6 文件名

---

**printf命令**

语法：printf '输出类型输出格式' 输出内容

输出类型：

* %ns：输出字符串。n是数字，代表输出几个字符串
* %ni：输出整数。n是数字，代表输出几个数字
* %m.nf：输出浮点数。m和n是数字，代表输出的整数数位和小数数位。例如%8.2f代表共输出8位整数，其中2位是小数，6位是整数

输出格式：

* \a：输出警告音
* \b：输出退格键，也就是Backspace键
* \f：清除屏幕
* \n：换行
* \r：回车，也就是Enter键
* \t：水平输出退格键，也就是Tab键
* \v：垂直输出退格键，也就是Tab键

**在awk命令中的输出支持print和printf命令**

print：会在每个输出之后自动加入一个换行符（Linux默认没有print命令）

printf：是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手动添加换行符

---

**awk命令**

语法：awk "条件1{动作1} 条件2{动作2}..." 文件名

条件：一般使用关系表达式位条件

* x > 10：判断变量是否大于10
* x >= 10：大于等于
* x <=10：小于等于

动作：

* 格式化输出
* 流程控制语句

BEGIN条件：在文件读取之前执行动作

FS内置变量：定义分割符（FS=":"）

END条件：在文件读取之后再执行动作

---

**sed命令**

sed是一种几乎包括在Unix平台的轻量级六编辑器，sed主要用来将数据进行选取，替换，删除，新增的命令

语法：sed [选项] '[动作]' 文件名

常用选项：

* -n：一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕
* -e：允许对输入数据应用多条sed命令编辑
* -i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出

动作：

* a\：追加，在当前行后添加一行或多行，添加多行时，除最后一行外，每行末尾需要用“\”表示数据未完结
* c\：行替换，用c后面的字符串替换原来数据行，替换多行时，除最后一行外，每行末尾需要用“\”表示数据未完结
* i\：插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用“\”表示数据未完结
* d：删除，删除指定的行
* p：打印，输出指定的行
* s：字串替换，用一个字符串替换另一个字符串，格式我“行范围s/旧字符/新字串/g”

---

### sort排序命令

功能描述：sort工具用于==排序==，他将文件的每一行作为一个单位，从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出

语法：

> sort [选项] 文件名

常用选项：

> * -u：去除重复行
> * -f：忽略大小写
> * -n：以数值型（数字）排序，默认使用字符串型排序
> * -r：降序排列，默认是升序
> * -o：将排序结果输出到文件中，类似重定向符号
> * -t：指定分隔符，默认分隔符是制表符
> * -b：忽略前导空格
> * -k，n[,m]：按照指定字段范围排序，从第n字段开始，m字段结束（默认到行尾）
> * -R：随机排序，每次运行结果都不同

---

### uniq命令

功能描述：uniq用于==去除连续重复的行==

语法：

> uniq [选项] 文件名

常用选项：

> * -i：忽略大小写
> * -c：统计重复行次数
> * -d：只显示重复行

---

### tee命令

功能描述：tee命令是从标准输入读取并写入到标准输出和文件，即：双向覆盖重定向（屏幕输出|文本输入）

语法：

> tee [选项] 文件名

常用选项：

> -a：以追加的方式写入文件

---

### diiff命令

功能描述：diff命令用于逐行比较文件的不同

注：diff描述两个文件不同的方式是告诉我们==怎样改变第一个文件==后能==与第二个文件匹配==

语法：

> diff [选项] 文件1 文件2

常用选项：

> -b：不检查空格
>
> -B：不检查空白行
>
> -i：不检查大小写
>
> -w：忽略所有空格
>
> -c：上下文格式显示
>
> -u：合并格式显示
>
> --normal：正常格式显示（默认）

---

### paste命令

功能描述：paste命令用于合并文件行

语法：

>paste [选项] 文件1 文件2

常用选项：

>* -d：自定义分隔符，默认是制表符
>* -s：串行处理，非并行

---

### tr命令

功能描述：tr命令用于字符转换，替换和删除，主要用于删除文件中控制字符或进行字符转换

用法：

>用法1：tr处理的内容来自文件，记住要使用"<"标准输入
>
>例如：tr '要匹配的字符' '要替换的字符' < 文件名
>
>用法2：匹配相应字符进行相应操作，如删除操作
>
>例如：tr [选项] '要匹配的字符' < 文件名
>
>用法3：命令的执行结果交给tr处理
>
>例如：commands | tr '要匹配的字符' '要替换的字符'



---

### 条件判断

**按照文件类型进行判断**

| 测试选项    | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| -b 文件     | 判断该文件是否存在，并且是否为块设备文件（是块设备文件为真） |
| -c 文件     | 判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真） |
| ==-d 文件== | 判断该文件是否存在，并且是否为目录文件（是目录文件为真）     |
| ==-e 文件== | 判断该文件是否存在（存在为真）                               |
| ==-f 文件== | 判断该文件是否存在，并且是否为普通文件（是普通文件为真）     |
| ==-L 文件== | 判断该文件是否存在，并且并且是否为符号链接文件（是符号链接文件为真） |
| -p 文件     | 判断该文件说法存在，并且是否为管道文件（是管道文件为真）     |
| -s 文件     | 判断该文件是否存在，并且是否为非空（非空为真）               |
| -S 文件     | 判断该文件是否存在，并且是否为套接字文件（是套接字文件为真） |

**两种判断格式**：

语法1：test [选项] 文件名

语法2：[[选项] 文件名]

**按照文件权限进行判断**

| 测试选项 | 作用                                                       |
| -------- | ---------------------------------------------------------- |
| -r 文件  | 判断该文件是否存在，并且是否拥有读权限（有读权限为真）     |
| -w 文件  | 判断该文件是否存在，并且是否拥有写权限（有写权限为真）     |
| -x 文件  | 判断该文件是否存在，并且是否拥有执行权限（有执行权限为真） |
| -u 文件  | 判断该文件是否存在，并且是否拥有SUID权限（有SUID权限为真） |
| -g 文件  | 判断该文件是否存在，并且是否拥有GUID权限（有GUID权限为真） |
| -k 文件  | 判断该文件是否存在，并且是否拥有SBIT权限（有SBIT权限为真） |

**两个文件之间进行比较**

| 测试选项        | 作用                                                         |
| --------------- | ------------------------------------------------------------ |
| 文件1 -nt 文件2 | 判断文件1的修改时间是否比文件2的新（新为真）                 |
| 文件1 -ot 文件2 | 判断文件1的修改时间是否比文件2 的旧（旧为真）                |
| 文件1 -ef 文件2 | 判断文件1和文件2的inode是否一致，可以理解为两个文件是否为同一个文件，这个文件用于判断硬链接是个很好的方式 |

**两个整数之间的比较**

| 测试选项        | 作用                                       |
| --------------- | ------------------------------------------ |
| 整数1 -eq 整数2 | 判断整数1是否等于整数2（等于为真）         |
| 整数1 -ne 整数2 | 判断整数1是否不等于整数2（不等于为真）     |
| 整数1 -gt 整数2 | 判断整数1是否大于整数2（大于为真）         |
| 整数1 -lt 整数2 | 判断整数1是否小于整数2（小于为真）         |
| 整数1 -ge 整数2 | 判断整数1是否大于等于整数2（大于等于为真） |
| 整数1 -le 整数2 | 判断整数1是否小于等于整数2（小于等于为真） |

**字符串判断**

| 测试选项           | 作用                                           |
| ------------------ | ---------------------------------------------- |
| -z 字符串          | 判断字符串是否为空（为空返回真）               |
| -n 字符串          | 判断字符串是否为非空（非空返回真）             |
| 字符串1 == 字符串2 | 判断字符串1与字符串2是否相等（相等返回真）     |
| 字符串1 != 字符串2 | 判断字符串1与字符串2是否不相等（不相等返回真） |

**多重条件判断**

| 测试选项       | 作用                                       |
| -------------- | ------------------------------------------ |
| 判断1 -a 判断2 | 逻辑与，判断1和判断2同时为真，则结果才为真 |
| 判断1 -o 判断2 | 逻辑或，判断1和判断2有一个为真，则结果为真 |
| ! 判断         | 逻辑非，是原始判断式取反                   |

---

### 流程控制

#### if语句

**单分支if条件语句**

```shell
if [条件判断式]; then
程序
fi
```

或者

```shell
if [条件判断式]
then
程序
fi
```

注：

* if语句使用fi结尾，和一般语言使用大括号结尾不同
* [条件判断式]就是使用test命令判断，所以中括号和条件判断式之间必须有空格
* then后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割，也可以使用换行写入，换行写入就不需要“;”了

例：

```shell
#!/bin/bash
rate=$(df -h | grep "/dev/sda1" | awk '{printf $5 "\n"}' | cut -d "%" -f 1)
if [ $rate -ge 20 ]; then
echo "warning"
fi
```

---

**双分支if条件语句**

```shell
if [条件判断式]
then
条件成立时，执行的程序
else
条件不成立时，执行的程序
fi
```

**多分支if条件语句**

```shell
if [条件判断式1]
then
当条件判断式1成立时，执行程序1
elif [条件判断式2]
then
当条件判断式2成立时，执行程序2
...
else
当条件判断式都不成立时，执行最后的程序
fi
```

---

#### case语句

多分支case条件语句

case语句和if...elif...else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系

```shell
case $变量名 in
"值1")
如果变量的值等于1，则执行程序1
;;
"值2")
如果变量的值等于2，则执行程序2
;;
...
*)
如果变量的值都不是以上的值，则执行此程序
;;
esac
```

---

#### for循环

语法1：

```shell
for 变量 in 值1 值2 值3...
do
程序
done
```

注：数值以此赋于变量，以此执行循环操作

语法2：

```shell
for ((初始值;循环控制条件;变量变化))
do
程序
done
```

---

#### while循环

while循环是不定循环，也称作条件循环。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止，这就是和for的固定循环不太一样

语法：

```shell
while[条件判断式]
do
程序
done
```

#### until循环

until循环和while循环相反，until循环是只要判断式不成立则进行循环，并执行循环程序，一旦循环条件成立，则终止循环

```shell
until[条件判断式]
do
程序
done
```

---



