# JavaScript笔记

`W3School的JavaScript教程`：https://www.w3school.com.cn/js/index.asp

浏览器分为两部分：`渲染引擎`，`JavaScript引擎`。

`渲染引擎`：用来解释HTML和CSS，俗称内核。

`JavaScript`引擎：也称`JavaScript`解释器，用来读取网页中的`JavaScript`代码，对其处理后运行。

浏览器本身是不会执行`JavaScript`代码的，而是通过内置的`JavaScript`引擎来执行`JavaScript`代码。`JavaScript`代码是逐行解释的，因此`JavaScript`属于脚本语言。所谓的脚本语言就是指不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序的脚本。

`JavaScript`也是一种嵌入式语言，`JavaScript`本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。`JavaScript`本身不提供任何与I/O相关的API，都要依靠宿主环境供，所以`JavaScript`只合适嵌入更大型应用程序环境，去调用宿主环境提供的底层API。

目前，已经嵌入`JavaScript`的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是Node项目。

## JavaScript的组成

`JavaScript`由三部分组成：`ECMAScript`，`DOM`，`BOM`。

`ECMAScript`：规定了`JavaScript`编程语法和基础核心知识。是所有浏览器厂商共同遵守的一套`JavaScript`语法工业标准。

`DOM`：文档对象模型，是一种可以处理标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作。

`BOM`：浏览器对象模型，提供了独立于内容的，可以与浏览器窗口交互的对象结构。通过BOM可以操作浏览器窗口。

## JavaScript代码的引入

类似css代码的引入方式，`JavaScript`代码通过`script`标签引入`JavaScript`代码。

#### 引入外部JavaScript代码

```javascript
<script type="text/javascript" src="url"><script>
```

## 严格模式

严格模式是为`JavaScript`定义了一种不同的解析与执行模型。

要在整个脚本中启动严格模式，可以在顶部添加`use strict`。也可以在指定函数内部启用严格模式，在指定的函数内部添加`use strict`就可以在函数中启用严格模式。

在严格模式下，`JavaScript`的执行结果会有很大的不同。

## JavaScript输入输出语句

| 方法             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| alert(msg)       | 浏览器弹出警示框                                             |
| console.log(msg) | 浏览器控制台打印输出信息                                     |
| prompt(info)     | 浏览器弹出输出框，用户可以输入(prompt取得的值是字符串类型的) |

## JavaScript的值

JavaScript语句中定义了两种类型的值：`混合值`，`变量值`。

`混合值`称为字面量，`变量值`称为变量。

#### 字面量

字面量是在源代码中一个`固定(不可改变)值`的表示法。通俗来说，字面量就是如何表达这个值。

数字字面量：8，9，0

字符串字面量："JavaScript"

布尔字面量：true，false

#### 变量

变量是用于存放数据的容器，通过变量名可以获取数据，甚至修改数据。

变量的本质：变量是在内存中申请一块用来存放数据的空间

```
1. 尽量不要使用name作为变量名，在某些浏览器中name有特殊含义。
2. 使用var操作符定义的变量将成为定义该变量的作用域中的局部变量。
3. 省略var操作符，直接给变量赋值，则变量会提升为全局变量。
```

#### 变量提升

`JavaScript`引擎的工作方式是先解析代码，获取所有被声明的变量，然后再一行一行地运行。因此，所有的变量的声明语句都会被提升到代码的头部，这就叫做变量提升。

```
console.log(a);
var a = 1;
```

上面的代码首先使用`console.log`方法，在控制台打印a的值。这时a还没有声明和赋值，所以这是一种错误的做法，但是实际运行不会报错。因为存在变量提升，实际运行的是下面的代码。

```
var a;
console.log(a);
a = 1;
```

最后结果显示的是`undefined`，表示变量a已经声明，但还没赋值。

## 数据类型

`JavaScript`是一种弱类型语言或者说是动态语言。

`JavaScript`的数据类型是在程序运行过程中，通过赋于的值来确定的。

`JavaScript`中变量的数据类型是可以变化的。

#### 数据类型的分类

`JavaScript`把数据类型分为两类：`基本数据类型`，`引用数据类型`。

```
1. 基本数据类型：Number（数值），String（字符串），Boolean（布尔），Undefined（未定义），Null（对空），Symbol（ES6引入）。
2. 引用数据类型：Object（对象），Array（数组），函数（function）。
```

ps : `isNaN()`方法可以判断是否为`非数字`的类型，是数字返回false；不是数字返回true。

## Srting（字符串类型）

字符串被引号包裹，可以使用双引号或单引号。

字符串一旦被创建，他们的值就不能改变。要改变某个变量中保存的字符串，首先要销毁原来的字符串，然后再使用另一个包含新值的字符串填充该变量。

#### 字符串的长度

字符串由若干字符组成，字符的数量就是字符串的长度。通过字符串的lenght属性可以获取整个字符串的长度。

#### 字符串的拼接

多个字符串之间可以使用+进行拼接。

拼接方式：字符串+任何类型=拼接之后的新字符串。

这种方法同时使用在字符串和变量之间的相加。

## Number（数值）

在`JavaScript`中只有一种数值类型`Number`(包括了整数和浮点数)。

浮点运算的结果不能精确，尽量不要在金钱方面使用浮点运算。

## 布尔型

布尔型只有两个值：`ture`，`false`。

```
1. 布尔值常用于条件判断。
2. 布尔值参加运算的时候ture看作1，false看作0。
```

## Undefined和Null

Null数据类型只有一个值：`null`。

```
1. null用来表示一个空对像。
```

Undefined数据类型只有一个值：`undefined`。

```
1. 在使用var声明变量但未加以初始化时，这个变量的值就是undefined。
```

ps : `undefined`和`null`数值相加得到NaN。

## 数据类型转换

把一个数据类型强制转换成另一个数据类型。

#### 其他类型转换为字符串类型

| 方式                       | 说明                       | 案例                                |
| -------------------------- | -------------------------- | ----------------------------------- |
| toString()方法             | 转换成字符串               | var num=1; alert(num.toString());   |
| String()函数               | 转换成字符串               | var num=1; alert(String(num));      |
| 加号拼接字符串（隐式转换） | 和字符串相加结果都是字符串 | var num=1; alert(num+"JavaScript"); |

```
1. Null和Undefined这两种数据类型没有toString()方法。
2. 调用String()函数，会直接将Null转换成“null”，Undefined转换成“undefined”。
```

#### 其他类型转换成数字类型

| 方式                       | 说明                     | 案例                |
| -------------------------- | ------------------------ | ------------------- |
| parselnt(String)函数       | 将String类型转换成整数型 | parselnt('69')      |
| parseFloat(String)函数     | 将String类型转换成浮点型 | parseFloat('69.69') |
| Number()强制类型转换       | 将String类型转换成数值型 | Number('69')        |
| JavaScript隐式转换(减乘除) | 利用算术运算隐式转换     | '69'-69             |

```
1. 在JavaScript中，以0x开头的表示十六进制数字，以0开头的表示八进制数字。
2. parseFloat(String)函数只能解析十进制数。
3. 在使用parselnt(String)函数转换的时候，可以在转换的字符后添加基数，即转换成多少进制数。
```

#### 其他类型转换成布尔型

| 方式          | 说明                 | 案例            |
| ------------- | -------------------- | --------------- |
| Boolean()函数 | 其他类型转换成布尔型 | Boolean('true') |

```
1. 表示空，否定的值会被转换成false。例如，''（空字符串），0，NaN，null，undefined。
```

## 运算符

也称为操作符，用于实现赋值，比较，算术运算等功能的符号。

#### 表达式和返回值

表达式：由数字，运算符，变量等组成的式子。

表达式最终会有一个结果返回给用户，返回的结果称为返回值。

#### 算数运算符

| 运算符 | 作用                   |
| ------ | ---------------------- |
| +      | 实现加法运算           |
| -      | 实现减法运算           |
| *      | 实现乘法运算           |
| /      | 实现除法运算           |
| %      | 实现取模运算（取余数） |
| ++     | 自增                   |
| --     | 自减                   |

```
1. 前置递增（递减）运算：先自加（减），后返回值。
2. 后置递增（递减）运算：先返回值，后自加（减）。
3. 前（后）置单独使用的时候效果一样。
4. 浮点数的数值最高精度是17位小数，在算术运算时会出现精度问题。
5. 不要直接判断两个浮点数是否相等。
6. 取模运算一般用于判断一个数是否能被整除。
```

#### 计较运算符

运算结果返回的是一个布尔值。

| 运算符 | 说明                             | 案例      | 结果  |
| ------ | -------------------------------- | --------- | ----- |
| &lt;   | 小于号                           | 1&lt;2    | true  |
| &gt;   | 大于号                           | 1&gt;2    | false |
| &gt;=  | 大于等于                         | 1&gt;=2   | false |
| &lt;=  | 小于等于                         | 1&lt;=2   | true  |
| ==     | 判等号（会转型）                 | 37==37    | true  |
| !=     | 不等号                           | 37!=37    | false |
| ===    | 全等号，要求数值和数据类型都相等 | 37==='37' | false |

#### 逻辑运算符

用于进行布尔值运算，其返回值也是布尔值，多用于条件判断。

| 运算符 | 说明          | 案例            |
| ------ | ------------- | --------------- |
| &&     | 逻辑与（and） | true && false   |
| \|\|   | 逻辑或（or）  | true \|\| false |
| !      | 逻辑非（not） | !true           |

短路运算(逻辑中断)

```
1. 短路运算原理：当有多个表达式的时候，左边的表达式可以确定运算结果则不再往右运算。
```

#### 赋值运算符

把数据赋值给变量。

| 运算符     | 说明                     | 案例                    |
| ---------- | ------------------------ | ----------------------- |
| =          | 直接赋值                 | var age=2 //2           |
| +=，-=     | 加（减）一个数后再赋值   | var age=2; age+=5 //7   |
| *=，/=，%= | 乘（除）（取模）后再赋值 | var age=2; age*=5 // 10 |

#### 类型运算符

| 运算符     | 说明                               |
| ---------- | ---------------------------------- |
| typeof     | 返回变量的类型                     |
| instanceof | 返回true，如果对象是对象类型的实例 |

typoef可以用来获取检测变量的数据类型

```javascript
typoef 变量名;
```

#### 运算符的优先级

| 优先级 | 运算符     | 顺序                     |
| ------ | ---------- | ------------------------ |
| 1      | 小括号     | （）                     |
| 2      | 一元运算符 | ++，--，！               |
| 3      | 算术运算符 | 先乘除后加减             |
| 4      | 关系运算符 | &lt;，&gt;，&gt;=，&lt;= |
| 5      | 相等运算符 | ==，!=                   |
| 6      | 逻辑运算符 | 先&&后\|\|               |
| 7      | 赋值运算符 | =                        |
| 8      | 逗号运算符 | ，                       |


## 基本语法

### 分支结构

---

根据不同的条件执行不同的代码。

#### if语句

```javascript
if(条件判断式) {
  执行语句   
}
```

执行思路

```
1. 如果条件判断式结果为真，则执行大括号中的语句。
2. 如果条件判断式结果为假，则执行大括号外的语句。
```

#### if else语句（双分支语句）

```javascript
if(条件判断式) {
  执行语句1
}else{
  执行语句2
}
```

执行思路

```
1. 如果条件判断式的结果为真，则执行语句1。
2. 如果条件判断式的结果为假，则执行语句2。
```

#### if else if语句（多分支语句）

利用多个条件来选择不同的语句执行，得到不同的结果。多选一。

```javascript
if(条件判断式1) {
  语句1
}else if(条件判断式2){
    语句2
}else{
    语句3
}
```

执行思路

```
1. 如果条件判断式1为真，则执行语句1。
2. 如果条件判断式1为假，则判断条件判断式2，如果条件判断式2为真，则执行语句2。
3. 如果条件判断1和条件判断式2都为假，则执行语句3。
```

#### switch语句

针对变量设置一系列特定值时，就可以使用`switch`语句。

```javascript
switch(表达式) {
  case value1:
  语句1
  break;
  case value2:
  语句2
  break;
  ...
  default:
  最后的语句
}
```

执行思路

```
1. 如果表达式的值和case的value值匹配则执行相应的语句。如果没有匹配的value值则执行default后的语句。
2. 表达式的值和value值需要全等匹配。
```

### 循环结构

---

一组被重复执行的代码称为循环体，终止条件决定循环次数。由循环体和终止条件组成的语句称为循环语句。

#### for循环

```javascript
for(初始化变量;条件判断式;操作表达式) {
    循环体
}
```

```
1. 初始化变量：通常用作计数器。
2. 条件判断式：通常用作终止条件。
3. 操作表达式：通常用于更新计数器。
```

#### 双重for循环

```javascript
for(外层初始化变量;外层条件判断式;外层操作表达式) {
  for(内层初始化变量;内层条件判断式;内层操作表达式) {
  ...
  }
}
```

#### while循环

`while`循环可以做条件判断式成立的时候执行循环体，直到条件判断式不成立。

```javascript
while(条件判断式) {
  循环体
}
```

执行思路

```
1. 条件判断式成立，则执行循环体，直到条件判断式不成立。
```

#### do while循环

```javascript
do {
  循环体
} while(条件判断式)
```

执行思路

```
1. 先执行一次循环体，再判断条件。
```

#### continue和break关键字

`break`关键字用于跳出整个循环。

用于立即跳出本次循环，继续执行剩余部分的循环（本次循环体中`continue`之后的代码会少执行一次）。

#### 三元表达式

```javascript
条件判断式 ? 表达式1 : 表达式2
```

执行思路

```
1. 如果条件判断式的结果为真，则返回表达式1的值；如果条件判断式的结果为假，则返回表达式2的值。
```

## 数组(Array)

数组是指一组数据的集合，数组中的每个数据称为元素，在数组中可以放任意类型的元素。数组可以将一组数据存放在单个变量名之下的。

#### 创建数组

利用数组的字面量创建数组。

```javascript
var <数组名> = []; // 创建一个空数组
var <数组名> = ['1','2',...]; //创建一个带初始值的数组
```

ps : 数组中的数据使用逗号分隔。

#### 数组的长度

使用`数组名.length`可以访问数组元素的长度。

遍历方式：通过for循环遍历。

#### 新增数组元素

通过修改数组长度`length`来实现数组的扩容。

```javascript
数组名.length=数值;
```

通过修改索引号实现数组扩容。

```javascript
数组名[数组下标]='数组元素'；
```

ps : 不要直接给数组名赋值。

## 函数(function)

函数就是封装了一段能够重复使用的代码块。

### 函数的声明

---

`JavaScript`有3种声明函数的方法。

#### function命令

`function`命令声明的代码块就是一个函数。`function`命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。

```javascript
function print(s) {
  console.log(s);
}
```

上面的代码命名了一个`print`函数。

#### 函数表达式

可以采用变量赋值的写法声明函数。

```javascript
var print = function(s) {
  console.log(s);
};
```

在变量中保存函数表达式之后，此变量可以用作函数。

这种写法将一个匿名函数赋值给变量。这个匿名函数又称函数表达式，因为赋值语句的等号右侧只能放表达式。

采用函数表达式声明函数时，`function`命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。

```javascript
var print = function x() {
  console.log(typeof x);
};

x // ReferenceError: x is not defined

print() // function
```

上面的代码在函数表达式中，加入了函数名`x`。这个`x`只在函数体内部可用，指代函数表达式本身，其他地方都不可用。

这种写法的用处有两个：

```
1. 可以在函数体内部调用自身
2. 方便除错(除错工具显示函数调用栈时，将显示函数名，而不再显示这是一个匿名函数)
```

因此，下面的形式声明函数也是非常常见。

```javascript
var f = function f() {};
```

需要注意的是，函数表达式需要在语句结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。

#### function构造函数

这种方式非常不直观，所以不常使用。

### return语句和递归

---

#### return语句

函数体内部的`return`语句表示返回。`JavaScript`引擎遇到`return`语句，就直接返回`return`语句后面的那个表达式的值，后面即使还有语句也不会再执行。`return`语句所带的表达式就是函数的返回值。`return`语句不是必要的，如果没有`return`语句，则该函数不返回任何值，或者返回`undefined`。

```javascript
function add(x, y) {
  return x + y;
}

add(1, 1);
```

#### 递归

函数可以调用自身，这就是递归。

### 函数的属性和方法

---

#### name属性

函数的`name`属性返回函数的名字。

### 立即调用的函数表达式

---

有时候需要定义函数之后，立即调用该函数。

## 同步与异步操作

### 单线程模型

---

单线程模型指的是，`JavaScript`只在一个线程上运行，同时只能执行一个任务，其他任务都必须在后面排队等待。

`JavaScript`引擎有多个线程，单个脚本只能在一个线程上运行，称为主线程，其他线程都是在后台配合。

`JavaScript`采用单线程的原因是不想让浏览器变得太复杂。

cpu可以不管IO操作，挂起处于等待中的任务，先运行排在后面的任务。等IO操作返回了结果，再回头，把挂起的任务继续运行下去。这就是`JavaScript`内部采用的"事件循环"机制。

html5提出web worker标准，运行`JavaScript`脚本创建多个线程，但是子线程完全受控与主线程，并且不得操作DOM。

### 同步任务和异步任务

---

程序里所有任务可以分为2类：同步任务，异步任务。

同步任务：没有被引擎挂起，在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行下一个任务。

异步任务：被引擎挂起，不进入主线程，而进入任务列表的任务。只有引擎认为某个异步任务可以执行了(比如Ajax操作从服务器得到了结果)，该任务(采用回调函数的形式)才会进入主线程。排异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有"阻塞"效应。

### 任务队列和事件循环

---

javascript运行时，除了一个正在运行的主线程，引擎还提供一个任务队列，里面是各种需要当前程序处理的异步任务。根据异步任务类型，存在多个任务队列。

主线程会去执行所有的同步任务。等到同步任务全部执行完成，就会去看任务队列里面的异步任务。如果条件满足，那么异步任务就重新进入主线程开始执行，这时这个异步任务就变成了同步任务。等到执行完成，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。

异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，就不会重新进入主线程。

只要同步任务执行完了，引擎就会一遍又一遍地检查挂起的异步任务是否满足条件进入主线程。这种循环检查的机制就是事件循环。

```
异步任务进入任务队列 -> 主线程执行同步任务，同步任务执行完成 -> 主线程查看任务队列，满足条件的异步任务重新进入主线程，变成同步任务 -> 下一异步任务进入主线程 -> 任务队列清空，程序结束执行 
```

### 异步操作模式

---

异步操作的几种模式。

```
1. callback回调函数
2. generator + co库
3. promise
4. async + await
```

#### 回调函数

回调函数是异步操作的最基本方法。

下面代码中，函数f1和函数f2，编程意图是函数f2必须等到函数f1执行完成，才能执行。

```javascript
function f1() {
  ...
}

function f2() {
  ...
}

f1();
f2();
```

如果函数f1是异步操作，函数f2就会立即执行，不会等到函数f1结束在执行。

可以考虑将函数f1改写，把函数f2写成函数f1的回调函数。

```javascript
function f1(callback) {
  ...
  callback();
}

function f2() {
  ...
}

f1(f2);
```

回调函数各个部分之间高度耦合，使得程序结构混乱，流程难以追踪，而且每个任务只能指定一个回调函数。

#### 事件监听

另一种思路就是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而是取决于某个事件是否发生。
















